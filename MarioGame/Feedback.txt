Functionality: 45/45
Non-Moving Non-Animated Sprite -- 5/5
Non-Moving Animated Sprite -- 10/10
Moving Non-Animated Sprite -- 10/10
Moving Animated Sprite -- 10/10
Keyboard Input-- 5/5
Gamepad Input-- 5/5
Additional Features Bonus -- 0

Implementation: 60/55
IController – 5/5
Controllers --  15/15
IAnimated Sprite – 5/5
Sprite Classes – 15/15
Overall – 15/15

Bonuses: 5
5 – Command Pattern

Total: 105/100

Background of image not utilizing transparency
Unfortunately, for JPGs with no ALPHA channel, the background color key is noneditable in the current version of the MonoGame pipeline.

The framework of the game looks familiar 
Not too much to say about the Controllers implementation.  Much looks pretty straightforward from perhaps CommandPattern Example.
The only new class would be the GamepadController.  The key difference is in the constructors – the piece I’m not particularly fond of is the implementation detail that perhaps Game knew about each of the controllers and how they were tracking commands (Dictionary). Your Stage had to construct two different Dictionaries and then pass for copy to the controllers versus just “registering” the commands with the Controller through ICommand and Keys or Buttons.

look what I found as a carryover in Game1.cs Update
            if ((GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed) ||
                Keyboard.GetState().IsKeyDown(Keys.Escape))
                Exit();

Sprites
I like that you deferred to the concrete Sprite classes for Loading of texture.
Proper interfaces in ISprite for Property Visible, Load, Update and Draw.
The implementation is fairly clean.


######NOTES FROM ADAM###########
What I gathered from this:
1. Change images to png or something else with transparency
2. Change Controllers to have an AddCommand Function instead of building a dictionary when they are created
3. Clear the escape key quit command that I left in from the default solution (whoops).

These are all pretty easy fixes and should be done by me fairly quickly.